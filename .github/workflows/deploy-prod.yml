name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.2.3)'
        required: true
        type: string
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  WEB_IMAGE_NAME: ${{ github.repository }}-web

jobs:
  # Build and push production images
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_TOKEN }}
    
    - name: Extract version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${GITHUB_REF#refs/heads/}-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
    
    - name: Extract metadata for main image
      id: meta-main
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=${{ steps.version.outputs.version }}
          type=raw,value=latest
          type=sha,prefix={{branch}}-
    
    - name: Extract metadata for web image
      id: meta-web
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ steps.version.outputs.version }}
          type=raw,value=latest
          type=sha,prefix={{branch}}-
    
    - name: Build and push main Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta-main.outputs.tags }}
        labels: ${{ steps.meta-main.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          BUILD_DATE=${{ fromJSON(steps.meta-main.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
    
    - name: Build and push web Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.web
        push: true
        tags: ${{ steps.meta-web.outputs.tags }}
        labels: ${{ steps.meta-web.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          BUILD_DATE=${{ fromJSON(steps.meta-web.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
    
    - name: Generate SBOM for main image
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
        format: spdx-json
        output-file: sbom-main.json
    
    - name: Generate SBOM for web image
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ steps.version.outputs.version }}
        format: spdx-json
        output-file: sbom-web.json
    
    - name: Upload SBOMs
      uses: actions/upload-artifact@v4
      with:
        name: sboms
        path: |
          sbom-main.json
          sbom-web.json
        retention-days: 90

  # Test production images
  test-production:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: web/package-lock.json
    
    - name: Install frontend dependencies
      working-directory: ./web
      run: npm ci
    
    - name: Install Playwright browsers
      working-directory: ./web
      run: npx playwright install --with-deps
    
    - name: Extract version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${GITHUB_REF#refs/heads/}-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
    
    - name: Create test environment file
      run: |
        cat > .env.test << EOF
        SIP_DOMAIN=test.example.com
        SIP_USER=testuser
        SIP_PASS=testpass
        OPENAI_API_KEY=test-key
        AGENT_ID=test-agent
        LOG_LEVEL=INFO
        PYTHONPATH=/app
        PYTHONUNBUFFERED=1
        PYTHONDONTWRITEBYTECODE=1
        EOF
    
    - name: Test production images with Docker Compose
      run: |
        # Create a test docker-compose file using the production images
        cat > docker-compose.prod-test.yml << EOF
        version: '3.8'
        services:
          sip-agent:
            image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
            container_name: sip-ai-agent-prod-test
            restart: unless-stopped
            volumes:
              - ./logs:/app/logs
            env_file:
              - .env.test
            ports:
              - "8080:8080"
              - "9090:9090"
              - "5060:5060/udp"
              - "16000-16100:16000-16100/udp"
            environment:
              - TZ=UTC
            healthcheck:
              test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:8080/healthz', timeout=5)"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
        
          web:
            image: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ steps.version.outputs.version }}
            container_name: sip-ai-web-prod-test
            restart: unless-stopped
            ports:
              - "8081:8080"
            depends_on:
              sip-agent:
                condition: service_healthy
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
        EOF
        
        # Test the production images
        docker-compose -f docker-compose.prod-test.yml up -d
        
        # Wait for services to be ready
        timeout 120 bash -c 'until docker-compose -f docker-compose.prod-test.yml exec sip-agent curl -f http://localhost:8080/healthz; do sleep 5; done'
        timeout 60 bash -c 'until docker-compose -f docker-compose.prod-test.yml exec web curl -f http://localhost:8080/healthz; do sleep 5; done'
        
        # Test health endpoints
        echo "Testing main service health..."
        docker-compose -f docker-compose.prod-test.yml exec sip-agent curl -f http://localhost:8080/healthz
        echo "Testing web service health..."
        docker-compose -f docker-compose.prod-test.yml exec web curl -f http://localhost:8080/healthz
        
        # Test web UI accessibility
        echo "Testing web UI accessibility..."
        docker-compose -f docker-compose.prod-test.yml exec web curl -f http://localhost:8080/ | head -20
    
    - name: Run E2E tests against production images
      working-directory: ./web
      run: |
        # Set the base URL to the web service
        export BASE_URL=http://localhost:8081
        npm run test:e2e
      env:
        CI: true
    
    - name: Upload E2E test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: prod-e2e-test-results
        path: |
          web/playwright-report/
          web/test-results/
        retention-days: 30
    
    - name: Cleanup
      if: always()
      run: |
        docker-compose -f docker-compose.prod-test.yml down -v
        docker system prune -f

  # Security scan production images
  security-scan-production:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Extract version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${GITHUB_REF#refs/heads/}-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
    
    - name: Run Trivy vulnerability scanner for main image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
        format: 'sarif'
        output: 'trivy-main-prod.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: Run Trivy vulnerability scanner for web image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ steps.version.outputs.version }}
        format: 'sarif'
        output: 'trivy-web-prod.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-main-prod.sarif'
    
    - name: Upload Trivy web scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-web-prod.sarif'

  # Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-production, security-scan-production]
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Extract version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${GITHUB_REF#refs/heads/}-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
    
    - name: Deploy to Production Server
      run: |
        echo "Deploying to production environment..."
        echo "Main image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
        echo "Web image: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ steps.version.outputs.version }}"
        
        # Here you would typically:
        # 1. SSH into your production server
        # 2. Pull the new images
        # 3. Update docker-compose.prod.yml with new image tags
        # 4. Restart services with zero-downtime deployment
        # 5. Run health checks
        # 6. Rollback if health checks fail
        
        echo "## Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Image |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Main Service | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| Web Service | \`${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ steps.version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Update your production server with the new images" >> $GITHUB_STEP_SUMMARY
        echo "2. Run \`docker-compose -f docker-compose.prod.yml pull && docker-compose -f docker-compose.prod.yml up -d\`" >> $GITHUB_STEP_SUMMARY
        echo "3. Verify services are healthy" >> $GITHUB_STEP_SUMMARY
        echo "4. Monitor logs and metrics" >> $GITHUB_STEP_SUMMARY
    
    - name: Run Production Health Checks
      run: |
        echo "Running production health checks..."
        # Here you would typically:
        # 1. Wait for services to be ready
        # 2. Test health endpoints
        # 3. Run smoke tests
        # 4. Check metrics and logs
        
        echo "Production health checks completed successfully!"
    
    - name: Notify Deployment Status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Production deployment successful!"
        else
          echo "❌ Production deployment failed!"
        fi
